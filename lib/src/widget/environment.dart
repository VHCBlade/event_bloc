import 'package:event_bloc/event_bloc_widgets.dart';
import 'package:flutter/widgets.dart';

/// Creates a bloc instance with [parentChannel] and using dependencies from
/// [reader]
typedef CreateBloc<T extends Bloc> = T Function(
  Readable reader,
  BlocEventChannel? parentChannel,
);

/// Creates a repository instance using dependencies from [reader]
typedef CreateRepository<T extends Repository> = T Function(Readable reader);

/// Provides a context for dependencies
// ignore: one_member_abstracts
abstract class Readable {
  /// [T] will find an instance saved under that class in the environment. Will
  /// throw an error if none can be found.
  T read<T>();
}

/// This builds a similar environment to the Flutter Widget Tree to be used for
/// Unit Tests. This allows the environment for the widget tests and unit tests
/// to be the same, so long as they use the same [blocBuilders] and
/// [repositoryBuilders].
///
/// For the Widget consumers of [blocBuilders] and [repositoryBuilders], please
/// look at [MultiRepositoryProvider] and [MultiBlocProvider]
class TestEnvironment implements Readable, Disposable {
  /// Creates a test environment using [blocBuilders] and [repositoryBuilders]
  ///
  /// This is made to mimic the [MultiRepositoryProvider] and
  /// [MultiBlocProvider] setup.
  TestEnvironment({
    required this.blocBuilders,
    required this.repositoryBuilders,
    RepositorySource? repositorySource,
  }) : repositorySource = repositorySource ?? RepositorySource();

  /// The source for the [BlocEventChannel] and [Repository]
  final RepositorySource repositorySource;

  /// Creates the blocs for the environment
  final List<BlocBuilder> blocBuilders;

  /// Creates the repositories for the environment
  final List<RepositoryBuilder> repositoryBuilders;

  final Map<Type, dynamic> _initializedMap = {};

  /// Will be true once [blocBuilders] and [repositoryBuilders] have been ran.
  bool initialized = false;

  @override
  T read<T>({bool allowUninitialized = false}) {
    if (!initialized && !allowUninitialized) {
      throw ArgumentError(
        'This test environment must be initialized before it is used!',
      );
    }

    return _initializedMap[T] as T;
  }

  /// Convenience function to get the nearest [BlocEventChannel], typically
  /// the [BlocEventChannel] of the last [Bloc] generated by [blocBuilders].
  BlocEventChannel get eventChannel =>
      read<BlocEventChannel>(allowUninitialized: true);

  /// Runs [blocBuilders] and [repositoryBuilders] if they haven't been ran
  /// before. You can access these using the [read] function.
  void initialize() {
    if (initialized) {
      return;
    }

    _initializedMap[BlocEventChannel] = repositorySource.channel;
    repositoryBuilders.forEach((element) {
      final repo = element.builder(
        ReadableFromFunc(<T>() => read<T>(allowUninitialized: true)),
      );
      _initializedMap[element.builderType] = repo;
      repo.initialize(eventChannel);
    });

    blocBuilders.forEach((element) {
      final bloc = element.builder(
        ReadableFromFunc(<T>() => read<T>(allowUninitialized: true)),
        eventChannel,
      );
      _initializedMap[element.builderType] = bloc;
      _initializedMap[BlocEventChannel] = bloc.eventChannel;
    });

    initialized = true;
  }

  @override
  void dispose() {
    if (!initialized) {
      return;
    }
    repositorySource.dispose();
    _initializedMap.forEach((key, value) {
      if (value is! Disposable) {
        return;
      }
      value.dispose();
    });
    initialized = false;
  }
}

/// Simple Implementation of [Readable]. Typically this will be used as an
/// Adapter.
class ReadableFromFunc implements Readable {
  /// [_read] will be the function that is called for [read].
  ReadableFromFunc(this._read);
  final T Function<T>() _read;

  @override
  T read<T>() => _read<T>();
}

/// This lets you define a builder for a [Bloc] that can be used for
/// [MultiBlocProvider] and [TestEnvironment]
///
/// Unlike with Provider, you need to specify the generic. Failing to do so
/// will set the generic to [Bloc] which is probably undesirable.
class BlocBuilder<T extends Bloc> {
  /// Unlike with Provider, you need to specify the generic. Failing to do so
  /// will set the generic to [Bloc] which is probably undesirable.
  BlocBuilder(this.builder);

  /// The function to create the instance of the bloc.
  final CreateBloc<T> builder;

  /// The type of the created bloc.
  Type get builderType => T;

  /// Generates the [BlocProvider] to be placed into the widget tree.
  BlocProvider<T> createProvider(Widget child) {
    return BlocProvider<T>.fromBuilder(builder: this, child: child);
  }
}

/// This lets you define a builder for a [Repository] that can be used for
/// [MultiRepositoryProvider] and [TestEnvironment]
///
/// Unlike with Provider, you need to specify the generic. Failing to do so
/// will set the generic to [Repository] which is probably undesirable.
class RepositoryBuilder<T extends Repository> {
  /// Unlike with Provider, you need to specify the generic. Failing to do so
  /// will set the generic to [Repository] which is probably undesirable.
  RepositoryBuilder(this.builder);

  /// The function to create the instance of the repository.
  final CreateRepository<T> builder;

  /// The type of the created repository.
  Type get builderType => T;

  /// Generates the [RepositoryProvider] to be placed into the widget tree.
  RepositoryProvider<T> createProvider(Widget child) =>
      RepositoryProvider<T>.fromBuilder(builder: this, child: child);
}
